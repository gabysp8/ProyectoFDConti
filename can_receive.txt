//#############################################################################
//
// FILE:   can_ex5_simple_receive.c
//
// TITLE:   CAN Simple Receive Example
//
//! \addtogroup driver_example_list
//! <h1> CAN simple example that illustrates data reception </h1>
//!
//! This example initializes CAN module A for Reception. When a frame with a
#include "driverlib.h"
#include "device.h"

# define LOOP_COUNT 10

// Defines
//
#define MSG_DATA_LENGTH    0   // "Don't care" for a Receive mailbox
#define RX_MSG_OBJ_ID      1   // Use mailbox 1

//
// Globals
//
uint16_t rxMsgData[8];
uint16_t Data;
volatile uint32_t rxMsgCount = 0;

//
// Main
//
void main(void)
{
    //
    // Initialize device clock and peripherals
    //
    Device_init();

    //
    // Initialize GPIO
    //
    Device_initGPIO();
    GPIO_setPadConfig(2, GPIO_PIN_TYPE_STD);
    GPIO_setDirectionMode(2, GPIO_DIR_MODE_OUT);
        //
        // Initialize PIE and clear PIE registers. Disables CPU interrupts.
        //
        Interrupt_initModule();

        //
        // Initialize the PIE vector table with pointers to the shell Interrupt
        // Service Routines (ISR).
        //
        Interrupt_initVectorTable();


	//
    // Configure GPIO pins for CANTX/CANRX
	//
    GPIO_setPinConfig(GPIO_70_CANRXA);
    GPIO_setPinConfig(GPIO_71_CANTXA);


    //
    // Configure GPIO pin which is toggled upon message reception
	//
    GPIO_setPadConfig(70, GPIO_PIN_TYPE_STD);
    GPIO_setDirectionMode(71, GPIO_DIR_MODE_OUT);

    //
    // Initialize the CAN controller
    //
    CAN_initModule(CANA_BASE);

    //
    // Set up the CAN bus bit rate to 500kHz for each module
    // Refer to the Driver Library User Guide for information on how to set
    // tighter timing control. Additionally, consult the device data sheet
    // for more information about the CAN module clocking.
    //
    CAN_setBitRate(CANA_BASE, DEVICE_SYSCLK_FREQ, 500000, 16);

    //
    // Initialize the receive message object used for receiving CAN messages.
    // Message Object Parameters:
    //      CAN Module: A
    //      Message Object ID Number: 1
    //      Message Identifier: 0x1
    //      Message Frame: Standard
    //      Message Type: Receive
    //      Message ID Mask: 0x0
    //      Message Object Flags: None
    //      Message Data Length: "Don't care" for a Receive mailbox
	//
    CAN_setupMessageObject(CANA_BASE, RX_MSG_OBJ_ID, 0x1,
                           CAN_MSG_FRAME_STD, CAN_MSG_OBJ_TYPE_RX, 0,
                           CAN_MSG_OBJ_NO_FLAGS, MSG_DATA_LENGTH);

    //
    // Start CAN module A operations
    //
    CAN_startModule(CANA_BASE);

    //
    // Start reception - Just wait for data from another node
	//
    while(1)
	{
	    //
	    // Poll RxOk bit in CAN_ES register to check completion of Reception
	    //
		if(((HWREGH(CANA_BASE + CAN_O_ES) & CAN_ES_RXOK)) == CAN_ES_RXOK) //CAN_O_ES (4) // Error and Status Register //CAN_ES_RXOK (16) // Reception status
		{
			//
			// Get the received message
			//
		    //CAN_IF1DATA Register    0x00000000

			CAN_readMessage(CANA_BASE, RX_MSG_OBJ_ID, rxMsgData);
			GPIO_togglePin(65U);
			rxMsgCount++;
		}

		Data = rxMsgData[0];
		if(Data == 0x0A){

		    for(;;)
		        {
		            //
		            // Turn on LED
		            //
		            GPIO_writePin(2, 0);

		            //
		            // Delay for a bit.
		            //
		            DEVICE_DELAY_US(250000);

		            //
		            // Turn off LED
		            //
		            GPIO_writePin(2, 1);

		            //
		            // Delay for a bit.
		            //
		            DEVICE_DELAY_US(250000);
		        }
		} else
		    if(Data == 0x0B){

		                for(;;)
		                    {
		                        //
		                        // Turn on LED
		                        //
		                        GPIO_writePin(2, 0);

		                        //
		                        // Delay for a bit.
		                        //
		                        DEVICE_DELAY_US(500000);

		                        //
		                        // Turn off LED
		                        //
		                        GPIO_writePin(2, 1);

		                        //
		                        // Delay for a bit.
		                        //
		                        DEVICE_DELAY_US(500000);
		                    }
		            } else
		                if(Data == 0x0C){

		                            for(;;)
		                                {
		                                    //
		                                    // Turn on LED
		                                    //
		                                    GPIO_writePin(2, 0);

		                                    //
		                                    // Delay for a bit.
		                                    //
		                                    DEVICE_DELAY_US(1000000);

		                                    //
		                                    // Turn off LED
		                                    //
		                                    GPIO_writePin(2, 1);

		                                    //
		                                    // Delay for a bit.
		                                    //
		                                    DEVICE_DELAY_US(1000000);
		                                }
		                        }


	}
}
